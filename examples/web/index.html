<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Agora Live Streaming – Mute & Volume Demo</title>
    <style>
      :root {
        --bg: #ffffff;
        --text: #111827;
        --muted: #6b7280;
        --border: #e5e7eb;
        --brand: #e11d48; /* pink/red for LIVE */
        --ok: #10b981;
        --warn: #f59e0b;
        --card-bg: #ffffff;
        --pill-bg: #374151;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #0b0f14;
          --text: #e5e7eb;
          --muted: #9ca3af;
          --border: #1f2937;
          --card-bg: #0f141a;
          --pill-bg: #111827;
        }
      }
      html, body { height: 100%; }
      body {
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 0; padding: 16px; max-width: 1100px; margin-inline: auto;
      }
      fieldset {
        margin: 16px 0; border: 1px solid var(--border); border-radius: 10px;
        background: var(--card-bg);
      }
      legend { padding: 0 8px; font-weight: 600; }
      label { display: inline-block; min-width: 160px; }
      input[type="text"], input[type="url"], select { width: 100%; max-width: 520px; }
      .row { margin: 10px 0; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      .video { width: 100%; max-width: 480px; aspect-ratio: 16/9; background: #111; border-radius: 8px; }
      #log { white-space: pre-wrap; background: #0b0f14; color: #e5e7eb; border: 1px solid var(--border); padding: 8px; height: 160px; overflow: auto; border-radius: 8px; }
      .panel { height: 160px; overflow: auto; border: 1px solid var(--border); padding: 8px; border-radius: 8px; background: #0b0f14; color: #e5e7eb; white-space: pre-wrap; }
      button { margin-right: 8px; padding: 10px 14px; border-radius: 8px; border: 1px solid var(--border); background: #111827; color: #e5e7eb; cursor: pointer; }
      button:disabled { opacity: .6; cursor: not-allowed; }
      .minor { color: var(--muted); font-size: 12px; }
      .muted { color: #ef4444; font-weight: 600; }
      .badge { margin-left: 8px; padding: 2px 8px; border-radius: 10px; font-size: 12px; vertical-align: middle; }
      .badge.ok { background: #064e3b; color: #34d399; border: 1px solid #065f46; }
      .badge.pending { background: #5b3b03; color: #fde68a; border: 1px solid #78350f; }
      .badge.error { background: #7f1d1d; color: #fecaca; border: 1px solid #991b1b; }
      .remote-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 12px; }
      .remote-item { width: 100%; max-width: 320px; aspect-ratio: 16/9; background: #000; position: relative; border-radius: 8px; overflow: hidden; }
      .remote-item .label { position: absolute; left: 6px; bottom: 4px; color: #fff; background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px; font-size: 12px; }
      /* KPI row for mobile/desktop */
      .kpi-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
      .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 10px; font-weight: 700; font-size: 12px; }
      .pill.live { background: linear-gradient(90deg, var(--brand), #f43f5e); color: #fff; }
      .pill.off { background: var(--pill-bg); color: #e5e7eb; font-weight: 600; }
      .kpi { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 10px; background: var(--pill-bg); color: #e5e7eb; }
      .kpi svg { width: 16px; height: 16px; }
      .spacer { flex: 1 1 auto; }
      @media (max-width: 900px) {
        .controls { grid-template-columns: 1fr; }
        label { min-width: 120px; }
      }
      @media (max-width: 640px) {
        .row { flex-direction: column; align-items: stretch; }
        label { width: 100%; }
        input[type="text"], input[type="url"], select, button { width: 100%; }
      }
    </style>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"></script>
  </head>
  <body>
    <h1>Agora Live Streaming – Mute & Volume <span id="sdkStatus" class="badge pending">SDK: not loaded</span></h1>
    <div id="secureWarn" style="display:none;margin:10px 0;padding:8px 12px;border:1px solid #f6c343;background:#fff8e1;color:#8a6d3b;font-size:14px;border-radius:6px"></div>
    <p class="minor">Use with the token server from <code>server/</code> (default http://localhost:4000).</p>

    <fieldset>
      <legend>Account (Auth)</legend>
      <div class="row">
        <label for="loginEmail">Email</label>
        <input id="loginEmail" type="text" placeholder="you@example.com" />
        <label for="loginPassword" style="margin-left:8px">Password</label>
        <input id="loginPassword" type="password" placeholder="password" />
        <button id="loginBackendBtn" type="button" style="margin-left:8px">Login</button>
        <button id="logoutBackendBtn" type="button" style="margin-left:8px">Logout</button>
        <span id="loginStatus" class="minor" style="margin-left:8px"></span>
      </div>
      <div class="row">
        <label style="min-width:160px">Register (optional)</label>
        <label style="margin-left:8px"><input type="radio" name="regRole" id="regRoleUser" value="user" checked /> user</label>
        <label style="margin-left:8px"><input type="radio" name="regRole" id="regRoleVendor" value="vendor" /> vendor</label>
        <label style="margin-left:8px">Name</label>
        <input id="registerName" type="text" placeholder="display name" />
        <button id="registerBackendBtn" type="button" style="margin-left:8px">Register</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Join Settings</legend>
      <div class="row">
        <label for="serverOrigin">Token server</label>
        <input id="serverOrigin" type="url" value="http://localhost:4000" />
        <span class="minor">/v1/rtc/token</span>
      </div>
      <div class="row">
        <label for="channel">Channel</label>
        <select id="channel" style="min-width:260px"></select>
      </div>
      <div class="row" id="vendorCreateRow" style="display:none">
        <label for="liveTitle">Title</label>
        <input id="liveTitle" type="text" placeholder="My Live" />
        <button id="createLiveBtn" type="button">Create Live</button>
        <span id="createLiveStatus" class="minor"></span>
      </div>
      <div class="row">
        <label for="uid">UID</label>
        <input id="uid" type="text" placeholder="Unique per channel (auto if empty)" />
        <span class="minor">Use a unique ID per client.</span>
      </div>
      <div class="row">
        <label>Role</label>
        <label><input id="roleHost" type="radio" name="role" value="host" disabled /> Host</label>
        <label><input id="roleAudience" type="radio" name="role" value="audience" disabled checked /> Audience</label>
        <span class="minor">(set by login)</span>
      </div>
      <details>
        <summary>Manual token (optional)</summary>
        <div class="row">
          <label for="appId">App ID</label>
          <input id="appId" type="text" placeholder="If using manual token" />
        </div>
        <div class="row">
          <label for="token">Token</label>
          <input id="token" type="text" placeholder="Paste a temp token to skip server" />
        </div>
      </details>
      <div class="row">
        <button id="joinBtn">Join</button>
        <button id="leaveBtn" disabled>Leave</button>
      </div>
    </fieldset>

    <div class="controls">
      <fieldset>
        <legend>Local Microphone</legend>
        <div class="row">
          <label for="muteLocal">Mute</label>
          <input id="muteLocal" type="checkbox" />
          <span id="muteLocalState" class="minor">unmuted</span>
        </div>
        <div class="row">
          <label for="localVol">Capture volume</label>
          <input id="localVol" type="range" min="0" max="400" value="100" />
          <span class="minor">0–400</span>
        </div>
      </fieldset>

      <fieldset>
        <legend>Local Camera</legend>
        <div class="row">
          <label>Facing</label>
          <label><input type="radio" name="camFacing" id="camFront" value="user" checked /> Front</label>
          <label style="margin-left:8px"><input type="radio" name="camFacing" id="camBack" value="environment" /> Back</label>
          <button id="switchCamBtn" type="button" style="margin-left:8px">Switch</button>
        </div>
        <div class="row">
          <label for="camSelect">Device</label>
          <select id="camSelect" style="min-width:260px"></select>
          <label style="margin-left:8px"><input id="mirrorPreview" type="checkbox" checked /> Mirror preview</label>
        </div>
      </fieldset>

      <fieldset>
        <legend>Remote Playback</legend>
        <div class="row">
          <label for="remoteVol">Playback volume</label>
          <input id="remoteVol" type="range" min="0" max="100" value="100" disabled />
          <span class="minor">0–100</span>
        </div>
        <div class="row minor">
          Remote users: <span id="remoteCount">0</span>
        </div>
      </fieldset>
    </div>

    <fieldset>
      <legend>Preview (Local)</legend>
      <video id="localVideo" class="video" autoplay playsinline muted style="transform: scaleX(-1);"></video>
    </fieldset>

    <fieldset>
      <legend>Live Backend (FastAPI) – Presence & Duration</legend>
      <div class="kpi-row" style="margin:8px 12px 0 12px">
        <span id="liveBadge" class="pill off" title="WebSocket status">LIVE</span>
        <span class="kpi" title="Current non-vendor viewers">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7Z"/><circle cx="12" cy="12" r="3"/></svg>
          <strong id="viewerCountLabel">0</strong>
        </span>
        <span class="kpi" title="Unique viewers this session">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7Z"/><circle cx="12" cy="12" r="0.01"/></svg>
          <strong id="viewsTotalLabel">0</strong>
        </span>
        <span class="kpi" title="Elapsed live duration"><strong id="liveDurationLabel">00:00:00</strong></span>
        <span class="spacer"></span>
      </div>
      <div class="row" style="padding:8px 12px 0 12px">
        <label for="backendOrigin">Backend origin</label>
        <input id="backendOrigin" type="url" value="https://192.168.102.133:8000" />
      </div>
      <div class="row" style="padding:0 12px">
        <label for="liveSessionId">Session ID</label>
        <select id="liveSessionId" style="min-width:260px"></select>
      </div>
      <!-- Auth controls removed here; use the top "Account (Auth)" section. JWT from login is used automatically. -->
      <div class="row" style="padding:0 12px 12px 12px">
        <button id="connectLiveBtn" type="button">Connect Live WS</button>
        <button id="disconnectLiveBtn" type="button" disabled>Disconnect</button>
        <button id="endLiveBtn" type="button" style="display:none">End Live (vendor)</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Remote Video</legend>
      <div id="remoteVideos" class="remote-grid"></div>
    </fieldset>

    <fieldset>
      <legend>Log</legend>
      <div id="log"></div>
    </fieldset>

    <fieldset>
      <legend>Comments (Signaling)</legend>
      <div class="row">
        <div id="chatLog" class="panel"></div>
      </div>
      <div class="row">
        <input id="chatInput" type="text" placeholder="Type a comment…" />
        <label style="margin-left:8px"><input id="dmToHost" type="checkbox" /> Send to Host privately</label>
        <span class="minor" style="margin-left:8px">Host UID: <span id="hostUidLabel">unknown</span></span>
        <button id="sendBtn" style="margin-left:8px" type="button">Send</button>
      </div>
    </fieldset>

    <script>
      const $ = (id) => document.getElementById(id);
      const logEl = $("log");
      function log(...args) {
        const line = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
        const time = new Date().toLocaleTimeString();
        logEl.textContent += `[${time}] ${line}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      // Surface runtime errors in the on-page log for easier debugging
      window.addEventListener('error', (e) => {
        try { log('Runtime error:', e.message); } catch (_) {}
      });
      window.addEventListener('unhandledrejection', (e) => {
        try { const msg = (e.reason && (e.reason.message || String(e.reason))) || 'unhandled rejection'; log(msg); } catch (_) {}
      });
      log('Demo script loaded');
      // Hydrate login/JWT fields from saved state so users don't paste tokens
      function updateJwtUi() {
        try {
          const jwtEl = document.getElementById('jwtToken');
          const hasLogin = !!(window.demoJwt && window.demoJwt.trim());
          if (!jwtEl) return;
          if (hasLogin) {
            if (!jwtEl.value) jwtEl.value = window.demoJwt; // reflect value
            jwtEl.disabled = true;
            jwtEl.placeholder = 'Using logged-in token';
          } else {
            jwtEl.disabled = false;
            jwtEl.placeholder = 'Paste Bearer JWT (optional)';
          }
        } catch(_) {}
      }
      (function hydrateLoginFromStorage(){
        try {
          const st = JSON.parse(localStorage.getItem('streammeon_state') || '{}');
          if (st.lastEmail && document.getElementById('loginEmail')) {
            document.getElementById('loginEmail').value = st.lastEmail;
          }
          if (st.jwt) {
            window.demoJwt = st.jwt;
            const status = document.getElementById('loginStatus');
            if (status && st.user) { status.textContent = `Logged in as ${st.user.name || 'user'}`; status.className = 'badge ok'; }
          }
          updateJwtUi();
        } catch(_) { /* noop */ }
      })();
      // Secure context check (getUserMedia requires HTTPS except on localhost)
      (function enforceSecureContext(){
        try {
          const warn = document.getElementById('secureWarn');
          const joinBtn = document.getElementById('joinBtn');
          const isLocalhost = /^(localhost|127\.0\.0\.1|\[::1\])$/.test(location.hostname);
          if (!window.isSecureContext && !isLocalhost) {
            const httpsUrl = `https://${location.host}${location.pathname}`;
            warn.innerHTML = `This page is not in a secure context. Browsers block mic/camera on HTTP.<br/>Open the secure link: <a href="${httpsUrl}">${httpsUrl}</a>`;
            warn.style.display = 'block';
          }
        } catch(_) {}
      })();
      // SDK status indicator helpers
      const sdkStatusEl = document.getElementById('sdkStatus');
      function setSdkStatus(text, cls) {
        if (!sdkStatusEl) return;
        sdkStatusEl.textContent = text;
        sdkStatusEl.className = `badge ${cls}`;
      }
      if (window.AgoraRTC) {
        const ver = window.AgoraRTC.VERSION || window.AgoraRTC.version || '';
        setSdkStatus(`SDK: loaded ${ver}`.trim(), 'ok');
      } else {
        setSdkStatus('SDK: not loaded', 'pending');
      }

      // Simple dynamic loader to ensure Agora SDK is present
      const SDK_CANDIDATES = [
        'https://download.agora.io/sdk/release/AgoraRTC_N.js',
        'https://download.agora.io/sdk/release/AgoraRTC_N-4.20.2.js',
        'https://cdn.jsdelivr.net/npm/agora-rtc-sdk-ng@4.20.2/AgoraRTC_N.js',
        'https://cdn.jsdelivr.net/npm/agora-rtc-sdk-ng@4.20.2/AgoraRTC_N-4.20.2.js'
      ];
      function isSameOrigin(u) {
        try { return new URL(u, location.href).origin === location.origin; } catch (_) { return false; }
      }
      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src; s.async = true;
          // Avoid setting crossOrigin for same-origin scripts (iOS WebKit quirk)
          if (!isSameOrigin(src)) s.crossOrigin = 'anonymous';
          s.onload = () => resolve();
          s.onerror = () => reject(new Error('Failed to load ' + src));
          document.head.appendChild(s);
        });
      }
      async function ensureAgoraSdk() {
        if (window.AgoraRTC) return window.AgoraRTC;
        for (const url of SDK_CANDIDATES) {
          try {
            setSdkStatus('SDK: loading…', 'pending');
            log('Loading SDK:', url);
            await loadScript(url);
            if (window.AgoraRTC) {
              const ver = window.AgoraRTC.VERSION || window.AgoraRTC.version || '';
              setSdkStatus(`SDK: loaded ${ver}`.trim(), 'ok');
              return window.AgoraRTC;
            }
          } catch (e) {
            log(e.message || e);
          }
        }
        setSdkStatus('SDK: failed to load', 'error');
        throw new Error('Unable to load Agora Web SDK');
      }

      // RTM/Signaling SDK loader
      const RTM_CANDIDATES = [
        // Same-origin proxy served by the token server to avoid iOS security errors on self-signed certs
        `${location.origin.replace(/\/$/, '')}/demo/rtm/agora-rtm.js`,
        'https://cdn.jsdelivr.net/npm/agora-rtm-sdk@2.2.3/agora-rtm.js',
        'https://unpkg.com/agora-rtm-sdk@2.2.3/agora-rtm.js'
      ];
      async function ensureRtmSdk() {
        if (window.AgoraRTM) return window.AgoraRTM;
        for (const url of RTM_CANDIDATES) {
          try { log('Loading RTM SDK:', url); await loadScript(url); if (window.AgoraRTM) return window.AgoraRTM; } catch (e) { log(e.message || e); }
        }
        throw new Error('Unable to load RTM SDK');
      }

      // When served from /demo, use the same origin for token server (works for IP/localhost, http/https)
      (function initServerOriginDefault() {
        try {
          const input = $("serverOrigin");
          if (!input) return;
          // only override when running under our demo route
          if (location.pathname.startsWith('/demo')) {
            input.value = location.origin;
          }
        } catch (_) { /* noop */ }
      })();

      // Ensure UID has a unique default if empty
      (function ensureDefaultUid() {
        const uidEl = $("uid");
        if (!uidEl) return;
        try {
          const st = JSON.parse(localStorage.getItem('streammeon_state') || '{}');
          const uidFromUser = st?.user?.id ? String(st.user.id) : '';
          if (uidFromUser) { uidEl.value = uidFromUser; return; }
        } catch (_) {}
        if (!uidEl.value) {
          const rand = Math.random().toString(36).slice(2, 8);
          uidEl.value = `user_${rand}`;
        }
      })();

      let client;
      let localAudioTrack;
      let localVideoTrack;
      let joined = false;
      // Hydrate logged-in user and lock role selection
      try {
        const st = JSON.parse(localStorage.getItem('streammeon_state') || '{}');
        if (st && st.user) { window.demoUser = st.user; }
      } catch (_) {}
      applyRoleFromLogin();
      const remoteUsers = new Map(); // uid -> { audioTrack, videoTrack }
      let currentRemoteAudioTrack = null;
      let rtm; // RTM client
      let rtmChannelName = '';
      let hostUid = '';

      async function fetchRtcToken(serverOrigin, channel, role, uid) {
        const params = new URLSearchParams({ channelName: channel, role, uid });
        const url = `${serverOrigin.replace(/\/$/, '')}/v1/rtc/token?${params}`;
        log('Fetching RTC token:', url);
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Token fetch failed: ${res.status}`);
        return res.json();
      }

      function getRole() {
        try {
          if (window.demoUser && window.demoUser.role) {
            return window.demoUser.role === 'vendor' ? 'host' : 'audience';
          }
        } catch (_) {}
        const el = document.querySelector('input[name="role"]:checked');
        return el ? el.value : 'audience';
      }

      function setUiJoined(state) {
        joined = state;
        $("joinBtn").disabled = state;
        $("leaveBtn").disabled = !state;
      }

      // Reflect role based on logged-in user: vendor → host, user → audience
      function applyRoleFromLogin() {
        try {
          const host = document.getElementById('roleHost');
          const aud = document.getElementById('roleAudience');
          if (!host || !aud) return;
          if (window.demoUser && window.demoUser.role) {
            const isVendor = window.demoUser.role === 'vendor';
            host.checked = !!isVendor; aud.checked = !isVendor;
            // Toggle vendor-only controls
            const row = document.getElementById('vendorCreateRow');
            if (row) row.style.display = isVendor ? 'flex' : 'none';
          }
          host.disabled = true; aud.disabled = true;
        } catch (_) {}
      }

      function updateRemoteState() {
        $("remoteCount").textContent = String(remoteUsers.size);
        const first = remoteUsers.values().next().value;
        currentRemoteAudioTrack = first ? first.audioTrack : null;
        $("remoteVol").disabled = !currentRemoteAudioTrack;
      }

      // Helpers for backend origin, session id, and vendor end capability
      function getBackendOrigin() {
        try { return (document.getElementById('backendOrigin').value || '').replace(/\/$/, ''); } catch (_) { return ''; }
      }
      function resolveSessionId() {
        try {
          const si = (document.getElementById('liveSessionId').value || '').trim();
          if (si) return si;
          return (document.getElementById('channel').value || '').trim();
        } catch (_) { return ''; }
      }
      function isVendorUser() {
        try { return (window.demoUser && window.demoUser.role === 'vendor') || getRole()==='host'; } catch (_) { return false; }
      }
      function canEndNow() { return !!(isVendorUser() && getBackendOrigin() && resolveSessionId()); }
      function updateEndButton() {
        const b = document.getElementById('endLiveBtn'); if (!b) return;
        b.style.display = canEndNow() ? 'inline-block' : 'none';
      }

      // Create live via FastAPI (vendor only)
      async function createLiveViaApi() {
        const statusEl = document.getElementById('createLiveStatus');
        try {
          if (!isVendorUser()) { if (statusEl) statusEl.textContent = 'Login as vendor'; return; }
          const origin = getBackendOrigin();
          const jwt = (window.demoJwt || '').trim();
          const title = (document.getElementById('liveTitle').value || '').trim() || 'My Live';
          if (!origin || !jwt) { if (statusEl) statusEl.textContent = 'Missing backend origin or login'; return; }
          if (statusEl) { statusEl.textContent = 'Creating…'; }
          const r = await fetch(`${origin}/live/sessions`, {
            method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${jwt}` }, body: JSON.stringify({ title })
          });
          if (!r.ok) { if (statusEl) statusEl.textContent = 'Create failed'; return; }
          const data = await r.json();
          const sid = data.session_id;
          // Prefill fields and lists; prefer this session
          try {
            const ch = document.getElementById('channel'); const si = document.getElementById('liveSessionId');
            if (ch) ch.value = sid; if (si) si.value = sid; updateEndButton();
          } catch (_) {}
          await refreshActiveSelects();
          if (statusEl) { statusEl.textContent = 'Live created'; }
        } catch (e) {
          if (statusEl) statusEl.textContent = 'Error creating live';
        }
      }

      async function refreshCameraList() {
        try {
          const cams = await AgoraRTC.getCameras();
          const sel = document.getElementById('camSelect');
          if (!sel) return;
          const old = sel.value;
          sel.innerHTML = '';
          for (const c of cams) {
            const opt = document.createElement('option');
            opt.value = c.deviceId;
            opt.textContent = c.label || `Camera ${c.deviceId.slice(0,6)}`;
            sel.appendChild(opt);
          }
          // restore selection if possible
          if (old) sel.value = old;
        } catch (_) {}
      }

      // ------------------------------
      // Active sessions list → populate selects for Channel and Session ID
      // ------------------------------
      async function fetchActiveSessions() {
        try {
          const origin = (document.getElementById('backendOrigin').value || '').replace(/\/$/, '');
          if (!origin) return [];
          const res = await fetch(`${origin}/live/sessions/active`);
          if (!res.ok) return [];
          const data = await res.json();
          return Array.isArray(data.items) ? data.items : [];
        } catch (_) { return []; }
      }
      function populateSelects(items) {
        try {
          const chSel = document.getElementById('channel');
          const siSel = document.getElementById('liveSessionId');
          if (!chSel || !siSel) return;
          const selCh = chSel.value;
          const selSi = siSel.value;
          const options = items.map(it => ({ value: it.session_id, label: `${it.title} — ${it.vendor?.name||''}` }));
          function render(sel, selectedVal) {
            sel.innerHTML = '';
            const ph = document.createElement('option'); ph.value = ''; ph.textContent = 'Select session'; sel.appendChild(ph);
            for (const o of options) {
              const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; sel.appendChild(opt);
            }
            if (selectedVal && options.some(o => o.value === selectedVal)) sel.value = selectedVal;
          }
          render(chSel, selCh);
          render(siSel, selSi);
        } catch (_) {}
      }
      async function refreshActiveSelects() {
        const items = await fetchActiveSessions();
        populateSelects(items);
        // If logged in as vendor, prefer prefill with their own session
        try {
          if (window.demoUser?.role === 'vendor') {
            const mine = items.find(it => String(it.vendor?.id) === String(window.demoUser?.id));
            if (mine) {
              const sid = mine.session_id;
              const ch = document.getElementById('channel');
              const si = document.getElementById('liveSessionId');
              if (ch) ch.value = sid;
              if (si) si.value = sid;
            }
          }
        } catch (_) {}
      }
      // keep in sync: channel ↔ session id (selects)
      (function syncChannelAndSession() {
        const ch = document.getElementById('channel');
        const si = document.getElementById('liveSessionId');
        if (ch) ch.addEventListener('change', () => { if (si) si.value = ch.value; });
        if (si) si.addEventListener('change', () => { if (ch) ch.value = si.value; });
      })();

      function getPreferredFacing() {
        const el = document.querySelector('input[name="camFacing"]:checked');
        return el ? el.value : 'user';
      }

      async function switchCameraByFacing(facing) {
        try {
          if (!localVideoTrack) return;
          const cams = await AgoraRTC.getCameras();
          // Try label match first
          const lc = (s) => (s||'').toLowerCase();
          let target = cams.find(c => /back|rear|environment/.test(lc(c.label))) ;
          if (facing === 'user') {
            target = cams.find(c => /front|user|face/.test(lc(c.label)));
          }
          // Fallback: pick first/last
          if (!target && cams.length) target = facing === 'user' ? cams[0] : cams[cams.length-1];
          if (target) {
            await localVideoTrack.setDevice(target.deviceId);
            localVideoTrack.play('localVideo');
            await refreshCameraList();
            document.getElementById('camSelect').value = target.deviceId;
            log('Switched camera to', target.label || target.deviceId);
          }
        } catch (e) { log('Switch camera error:', e.message || e); }
      }

      function updateHostUidLabel() {
        document.getElementById('hostUidLabel').textContent = hostUid || 'unknown';
      }

      async function join() {
        try {
          if (joined) return;
          if (!window.isSecureContext && !/^(localhost|127\.0\.0\.1|\[::1\])$/.test(location.hostname) && getRole()==='host') {
            throw new Error('This page is HTTP. Use HTTPS to publish mic/cam.');
          }
          // Ensure SDK is available
          await ensureAgoraSdk();
          const channel = $("channel").value.trim();
          const uid = $("uid").value.trim() || '0';
          const role = getRole();
          let appId, token, finalUid = uid;

          const manualToken = $("token").value.trim();
          if (manualToken) {
            appId = $("appId").value.trim();
            token = manualToken;
            if (!appId || !token) throw new Error('Manual token requires App ID and Token');
          } else {
            const serverOrigin = $("serverOrigin").value.trim() || 'http://localhost:4000';
            const t = await fetchRtcToken(serverOrigin, channel, role, uid);
            appId = t.appId; token = t.token; finalUid = String(t.uid ?? uid);
          }

          client = AgoraRTC.createClient({ mode: 'live', codec: 'vp8' });
          client.on('user-published', async (user, mediaType) => {
            log('user-published', user.uid, mediaType);
            await client.subscribe(user, mediaType);
            log('subscribed', user.uid, mediaType);
            if (!remoteUsers.has(user.uid)) remoteUsers.set(user.uid, {});
            const entry = remoteUsers.get(user.uid);
            if (mediaType === 'audio') {
              entry.audioTrack = user.audioTrack;
              try {
                await user.audioTrack.play(); // start playback
                log('remote audio playing', user.uid);
              } catch (err) {
                log('remote audio play error:', err.message || err);
              }
            } else if (mediaType === 'video') {
              entry.videoTrack = user.videoTrack;
              // Create container and play remote video
              const containerId = `remote-${user.uid}`;
              let el = document.getElementById(containerId);
              if (!el) {
                el = document.createElement('div');
                el.id = containerId;
                el.className = 'remote-item';
                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = `uid: ${user.uid}`;
                el.appendChild(label);
                const host = document.getElementById('remoteVideos');
                if (host) host.appendChild(el);
              }
              try {
                user.videoTrack.play(el);
                log('remote video playing', user.uid);
              } catch (err) {
                log('remote video play error:', err.message || err);
              }
              // Heuristic: the first remote with video is likely the Host
              if (!hostUid) { hostUid = String(user.uid); updateHostUidLabel(); }
            }
            updateRemoteState();
          });
          function cleanupRemote(user, mediaType) {
            log('user-unpublished', user.uid, mediaType);
            const entry = remoteUsers.get(user.uid);
            if (entry) {
              if (mediaType === 'audio' && entry.audioTrack) { entry.audioTrack.stop(); entry.audioTrack = null; }
              if (mediaType === 'video' && entry.videoTrack) {
                entry.videoTrack.stop();
                entry.videoTrack = null;
                const el = document.getElementById(`remote-${user.uid}`);
                if (el && el.parentNode) el.parentNode.removeChild(el);
              }
              if (!entry.audioTrack && !entry.videoTrack) remoteUsers.delete(user.uid);
            }
            if (String(user.uid) === hostUid && mediaType !== 'audio') { hostUid = ''; updateHostUidLabel(); }
            updateRemoteState();
          }
          client.on('user-unpublished', cleanupRemote);
          client.on('user-left', (user) => cleanupRemote(user, 'all'));

          client.setClientRole(role);
          await client.join(appId, channel, token || null, finalUid === '0' ? null : finalUid);
          log('Joined channel', channel, 'as', role, 'uid', finalUid);

          if (role === 'host') {
            const facing = getPreferredFacing();
            [localAudioTrack, localVideoTrack] = await Promise.all([
              AgoraRTC.createMicrophoneAudioTrack(),
              AgoraRTC.createCameraVideoTrack({ facingMode: facing })
            ]);
            localVideoTrack.play('localVideo');
            await client.publish([localAudioTrack, localVideoTrack]);
            log('Published local tracks');
            hostUid = String(finalUid);
            updateHostUidLabel();
            await refreshCameraList();
          }

          // Connect RTM and subscribe to comments channel (same as RTC channel)
          try {
            await ensureRtmConnected(channel, String(finalUid));
          } catch (err) {
            log('RTM error:', err.message || err);
          }

          setUiJoined(true);
        } catch (e) {
          log('Join error:', e.message || e);
          alert(e.message || e);
        }
      }

      async function leave() {
        try {
          if (!client) return;
          if (localVideoTrack) { localVideoTrack.stop(); localVideoTrack.close(); localVideoTrack = null; }
          if (localAudioTrack) { localAudioTrack.stop(); localAudioTrack.close(); localAudioTrack = null; }
          await client.unpublish();
          await client.leave();
          client.removeAllListeners();
          client = null;
          remoteUsers.clear();
          currentRemoteAudioTrack = null;
          if (rtm) {
            try { if (rtmChannelName) await rtm.unsubscribe(rtmChannelName); } catch (_) {}
            try { await rtm.logout(); } catch (_) {}
          }
          rtm = null; rtmChannelName='';
          updateRemoteState();
          setUiJoined(false);
          log('Left channel');
          // If this user is the vendor/host, try to end the live session on backend
          try {
            if (isVendorUser()) {
              const origin = getBackendOrigin();
              const sid = resolveSessionId();
              const jwt = (window.demoJwt || '').trim();
              if (origin && sid && jwt) {
                const res = await fetch(`${origin}/live/sessions/${encodeURIComponent(sid)}/end`, {
                  method: 'POST', headers: { 'Authorization': `Bearer ${jwt}` }
                });
                log('End live result:', res.status);
              }
            }
          } catch (_) {}
        } catch (e) {
          log('Leave error:', e.message || e);
        }
      }

      $("joinBtn").addEventListener('click', () => join());
      $("leaveBtn").addEventListener('click', () => leave());

      $("muteLocal").addEventListener('change', async (e) => {
        const muted = e.target.checked;
        try {
          if (localAudioTrack) {
            await localAudioTrack.setEnabled(!muted);
            $("muteLocalState").textContent = muted ? 'muted' : 'unmuted';
            $("muteLocalState").className = muted ? 'muted' : 'minor';
          }
        } catch (err) { log('Mute error:', err.message || err); }
      });

      $("localVol").addEventListener('input', (e) => {
        const v = Number(e.target.value);
        if (localAudioTrack) {
          try { localAudioTrack.setVolume(v); } catch (_) {}
        }
      });

      $("remoteVol").addEventListener('input', (e) => {
        const v = Number(e.target.value);
        if (currentRemoteAudioTrack) {
          try { currentRemoteAudioTrack.setVolume(v); } catch (_) {}
        }
      });

      // Camera controls
      document.getElementById('switchCamBtn').addEventListener('click', async () => {
        const facing = getPreferredFacing();
        await switchCameraByFacing(facing);
      });
      document.getElementById('camSelect').addEventListener('change', async (e) => {
        try {
          if (localVideoTrack) {
            await localVideoTrack.setDevice(e.target.value);
            localVideoTrack.play('localVideo');
          }
        } catch (err) { log('Switch by device error:', err.message || err); }
      });
      document.getElementById('camFront').addEventListener('change', async (e) => { if (e.target.checked) await switchCameraByFacing('user'); });
      document.getElementById('camBack').addEventListener('change', async (e) => { if (e.target.checked) await switchCameraByFacing('environment'); });
      document.getElementById('mirrorPreview').addEventListener('change', (e) => {
        const v = document.getElementById('localVideo');
        if (e.target.checked) { v.style.transform = 'scaleX(-1)'; }
        else { v.style.transform = ''; }
      });

      // Initialize UI state
      updateRemoteState();

      // Chat helpers
      function appendChat(text) {
        const log = document.getElementById('chatLog');
        if (!log) return;
        const time = new Date().toLocaleTimeString();
        log.textContent += `[${time}] ${text}\n`;
        log.scrollTop = log.scrollHeight;
      }
      let rtmSelfUid = null;
      async function ensureRtmConnected(channel, uid) {
        await ensureRtmSdk();
        // Sanitize channel for RTM (no dots or spaces; <=64 chars)
        function rtmSafeChannel(name) {
          const cleaned = String(name || '')
            .replace(/[^A-Za-z0-9_-]/g, '-')
            .replace(/-+/g, '-');
          return cleaned.slice(0, 64) || 'rtm';
        }
        const rtmChannel = rtmSafeChannel(channel);
        if (rtm && rtmChannelName === rtmChannel) { return rtm; }
        const origin = ($("serverOrigin").value.trim() || location.origin).replace(/\/$/, '');
        const r = await fetch(`${origin}/v1/rtm/token?uid=${encodeURIComponent(uid)}`);
        if (!r.ok) throw new Error('RTM token fetch failed');
        const { appId: rtmAppId, token: rtmToken } = await r.json();
        rtm = new AgoraRTM.RTM(rtmAppId, String(uid));
        rtmSelfUid = String(uid);
        rtm.addEventListener('status', (s) => log('RTM status', s.state, s.reason||''));
        rtm.addEventListener('message', (m) => {
          if (m.messageType !== 'STRING') return;
          if (m.channelType === 'MESSAGE' && m.channelName === rtmChannelName) {
            // Hide own group messages from self
            if (String(m.publisher) === String(rtmSelfUid)) return;
            appendChat(`${m.publisher}: ${m.message}`);
          } else if (m.channelType === 'USER') {
            appendChat(`DM ${m.publisher}: ${m.message}`);
          }
        });
        await rtm.login({ token: rtmToken });
        rtmChannelName = rtmChannel;
        await rtm.subscribe(rtmChannelName);
        log('RTM subscribed', rtmChannelName);
        return rtm;
      }

      let sending = false;
      async function sendChat() {
        if (sending) return;
        const inp = document.getElementById('chatInput');
        const msg = inp.value.trim();
        if (!msg) return;
        try {
          sending = true;
          const channel = $("channel").value.trim();
          const uidNow = $("uid").value.trim() || '0';
          if (!rtm || !rtmChannelName) {
            await ensureRtmConnected(channel, uidNow);
          }
          const dm = document.getElementById('dmToHost').checked;
          const myRole = getRole();
          if (dm && hostUid && myRole !== 'host') {
            await rtm.publish(hostUid, msg, { channelType: 'USER', storeInHistory: false });
            appendChat(`me → host(${hostUid}): ${msg}`);
          } else {
            await rtm.publish(rtmChannelName, msg, { channelType: 'MESSAGE', storeInHistory: false });
            // Show own message immediately in UI
            appendChat(`me (all): ${msg}`);
          }
          inp.value = '';
        } catch (e) { log('Send error:', e.message || e); }
        finally { sending = false; }
      }
      document.getElementById('sendBtn').addEventListener('click', sendChat);
      document.getElementById('chatInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); sendChat(); }
      });

      // ------------------------------
      // FastAPI live WS (presence + duration)
      // ------------------------------
      let liveWs = null;
      let liveTicker = null;
      let liveDurationSeconds = 0;
      let liveStartedAt = null; // ISO string or null
      let liveEnded = false;
      function fmtHMS(secs) {
        secs = Math.max(0, Math.floor(Number(secs)||0));
        const h = String(Math.floor(secs / 3600)).padStart(2,'0');
        const m = String(Math.floor((secs % 3600) / 60)).padStart(2,'0');
        const s = String(secs % 60).padStart(2,'0');
        return `${h}:${m}:${s}`;
      }
      function setLiveUi(connected) {
        const c = document.getElementById('connectLiveBtn');
        const d = document.getElementById('disconnectLiveBtn');
        if (c) c.disabled = connected;
        if (d) d.disabled = !connected;
        const live = document.getElementById('liveBadge');
        if (live) {
          live.className = 'pill ' + (connected ? 'live' : 'off');
          live.textContent = connected ? 'LIVE' : 'OFFLINE';
        }
      }
      function updateDurationLabel() {
        const el = document.getElementById('liveDurationLabel');
        if (el) el.textContent = fmtHMS(liveDurationSeconds);
      }
      function startTicker() {
        stopTicker();
        updateDurationLabel();
        liveTicker = setInterval(() => {
          if (liveEnded) { stopTicker(); return; }
          liveDurationSeconds += 1;
          updateDurationLabel();
        }, 1000);
      }
      function stopTicker() { if (liveTicker) { clearInterval(liveTicker); liveTicker = null; } }
      function updateViewerCount(n) {
        const el = document.getElementById('viewerCountLabel');
        if (el) el.textContent = String(n);
      }
      function updateViewsTotal(n) {
        const el = document.getElementById('viewsTotalLabel');
        if (el) el.textContent = String(n);
      }
      function connectLiveWs() {
        try {
          const origin = (document.getElementById('backendOrigin').value || '').replace(/\/$/, '');
          let sid = (document.getElementById('liveSessionId').value || '').trim();
          if (!sid) { try { sid = (document.getElementById('channel').value || '').trim(); } catch(_) {} }
          const jwtFromLogin = (window.demoJwt || '').trim();
          const jwtRaw = ((document.getElementById('jwtToken') && document.getElementById('jwtToken').value) || '').trim();
          // Prefer login token; otherwise accept raw token or 'Bearer ...'
          const jwt = (jwtFromLogin || jwtRaw).replace(/^Bearer\s+/i, '');
          if (!origin || !sid || !jwt) {
            alert('Please fill Backend origin, Session ID, and login (Account section)');
            return;
          }
          const url = `${origin.replace('http','ws')}/ws/live/${encodeURIComponent(sid)}?token=${encodeURIComponent(jwt)}`;
          log('Connecting live WS:', url);
          liveWs = new WebSocket(url);
          liveWs.onopen = () => { setLiveUi(true); log('Live WS connected'); };
          liveWs.onclose = (e) => { setLiveUi(false); log('Live WS closed', e.code, e.reason||''); stopTicker(); };
          liveWs.onerror = (e) => { log('Live WS error'); };
          liveWs.onmessage = (ev) => {
            try {
              const data = JSON.parse(ev.data);
              if (data.type === 'viewer_count') {
                updateViewerCount(data.count || 0);
                return;
              }
              if (data.type === 'views_total') {
                updateViewsTotal(data.total || 0);
                return;
              }
              if (data.type === 'session_info') {
                liveStartedAt = data.started_at || null;
                liveEnded = !!data.ended_at;
                // Prefer server-provided seconds as baseline
                liveDurationSeconds = Number(data.live_duration_seconds||0);
                startTicker();
                if (typeof data.viewer_count === 'number') updateViewerCount(data.viewer_count);
                if (typeof data.views_total === 'number') updateViewsTotal(data.views_total);
                return;
              }
              if (data.type === 'session_ended') {
                liveEnded = true;
                if (typeof data.live_duration_seconds === 'number') {
                  liveDurationSeconds = data.live_duration_seconds;
                  updateDurationLabel();
                }
                stopTicker();
                return;
              }
            } catch(_) {}
          };

          // Fallback init: fetch session info via REST in case the WS snapshot is delayed
          try {
            const restUrl = `${origin}/live/sessions/${encodeURIComponent(sid)}`;
            fetch(restUrl).then(r => r.ok ? r.json() : null).then((data) => {
              if (!data) return;
              if (typeof data.viewer_count === 'number') updateViewerCount(data.viewer_count);
              if (typeof data.views_total === 'number') updateViewsTotal(data.views_total);
              if (data.started_at) {
                const startedMs = Date.parse(data.started_at);
                const endedMs = data.ended_at ? Date.parse(data.ended_at) : null;
                if (!Number.isNaN(startedMs)) {
                  const nowMs = Date.now();
                  const baseMs = endedMs ?? nowMs;
                  const secs = Math.max(0, Math.floor((baseMs - startedMs) / 1000));
                  liveDurationSeconds = secs;
                  liveEnded = !!endedMs;
                  startTicker();
                }
              }
            }).catch(() => {});
          } catch (_) { /* noop */ }
        } catch (e) {
          log('Live WS connect error:', e.message || e);
        }
      }
      function disconnectLiveWs() {
        try { if (liveWs && liveWs.readyState === 1) liveWs.close(1000, 'client close'); } catch(_) {}
        liveWs = null; stopTicker(); setLiveUi(false);
      }
      document.getElementById('connectLiveBtn').addEventListener('click', connectLiveWs);
      document.getElementById('disconnectLiveBtn').addEventListener('click', disconnectLiveWs);
      document.getElementById('endLiveBtn').addEventListener('click', async () => {
        try {
          if (!canEndNow()) { log('Not allowed to end'); return; }
          const origin = getBackendOrigin();
          const sid = resolveSessionId();
          const jwt = (window.demoJwt || '').trim();
          const r = await fetch(`${origin}/live/sessions/${encodeURIComponent(sid)}/end`, { method:'POST', headers: { 'Authorization': `Bearer ${jwt}` }});
          log('End live:', r.status);
        } catch (e) { log('End live error', e?.message||e); }
      });
      // Keep the End Live button visibility fresh
      try {
        document.getElementById('channel').addEventListener('input', updateEndButton);
        document.getElementById('liveSessionId').addEventListener('input', updateEndButton);
        document.getElementById('backendOrigin').addEventListener('input', updateEndButton);
      } catch(_) {}
      // Populate active session lists initially and every 8s
      try { refreshActiveSelects(); setInterval(refreshActiveSelects, 8000); } catch (_) {}
      try { document.getElementById('backendOrigin').addEventListener('input', () => { refreshActiveSelects(); updateEndButton(); }); } catch (_) {}
      try { document.getElementById('createLiveBtn').addEventListener('click', createLiveViaApi); } catch (_) {}

      // ------------------------------
      // Backend login helper (stores JWT for WS)
      // ------------------------------
      function saveDemoState(extras) {
        try {
          const key = 'streammeon_state';
          const cur = JSON.parse(localStorage.getItem(key) || '{}');
          localStorage.setItem(key, JSON.stringify({ ...cur, ...extras }));
        } catch (_) {}
      }
async function loginBackend() {
        try {
          const origin = (document.getElementById('backendOrigin').value || '').replace(/\/$/, '');
          const email = (document.getElementById('loginEmail').value || '').trim();
          const password = document.getElementById('loginPassword').value || '';
          const status = document.getElementById('loginStatus');
          if (!origin || !email || !password) { status.textContent = 'Fill origin, email, password'; return; }
          status.textContent = 'Logging in…';
          const r = await fetch(`${origin}/auth/login`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password })
          });
          if (!r.ok) { status.textContent = 'Login failed'; status.className = 'badge error'; return; }
          const data = await r.json();
          window.demoJwt = data.access_token || '';
          // Persist token + user + last email for auto-fill on next load
          saveDemoState({ jwt: data.access_token || '', user: data.user || null, lastEmail: email });
          // Reflect in UI (disable manual input since we’ll use the login token)
          try { const jwtEl = document.getElementById('jwtToken'); if (jwtEl) { jwtEl.value = data.access_token || ''; } } catch(_) {}
          status.textContent = `Logged in as ${data?.user?.name || email}`;
          status.className = 'badge ok';
          updateJwtUi();
          // Apply UID and role from user
          try {
            if (data?.user?.id) { const uidEl = document.getElementById('uid'); if (uidEl) uidEl.value = String(data.user.id); }
            window.demoUser = data.user || null;
            applyRoleFromLogin();
          } catch (_) {}
          // Populate active sessions into datalists and prefill matching fields
          await refreshActiveSelects();
  updateEndButton();
} catch (e) {
  try { document.getElementById('loginStatus').textContent = 'Login error'; } catch (_) {}
}
}
async function registerBackend() {
  try {
    const origin = (document.getElementById('backendOrigin').value || '').replace(/\/$/, '');
    const email = (document.getElementById('loginEmail').value || '').trim();
    const password = document.getElementById('loginPassword').value || '';
    const name = (document.getElementById('registerName').value || '').trim() || email.split('@')[0];
    const role = (document.getElementById('regRoleVendor')?.checked) ? 'vendor' : 'user';
    const status = document.getElementById('loginStatus');
    if (!origin || !email || !password) { status.textContent = 'Fill origin, email, password'; return; }
    status.textContent = 'Registering…';
    const r = await fetch(`${origin}/auth/register`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password, name, role })
    });
    if (!r.ok) { status.textContent = 'Register failed'; status.className = 'badge error'; return; }
    await loginBackend();
  } catch (_) { try { document.getElementById('loginStatus').textContent = 'Register error'; } catch(_) {} }
}
function logoutBackend() {
  try {
    window.demoJwt = '';
    window.demoUser = null;
    saveDemoState({ jwt: '', user: null });
    const status = document.getElementById('loginStatus');
    if (status) { status.textContent = 'Logged out'; status.className = 'minor'; }
    updateJwtUi();
    applyRoleFromLogin();
    updateEndButton();
  } catch (_) {}
}
document.getElementById('loginBackendBtn').addEventListener('click', loginBackend);
document.getElementById('registerBackendBtn').addEventListener('click', registerBackend);
document.getElementById('logoutBackendBtn').addEventListener('click', logoutBackend);
    </script>
  </body>
  </html>
