<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Agora Live Streaming – Mute & Volume Demo</title>
    <style>
      :root {
        --bg: #ffffff;
        --text: #111827;
        --muted: #6b7280;
        --border: #e5e7eb;
        --brand: #e11d48; /* pink/red for LIVE */
        --ok: #10b981;
        --warn: #f59e0b;
        --card-bg: #ffffff;
        --pill-bg: #374151;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #0b0f14;
          --text: #e5e7eb;
          --muted: #9ca3af;
          --border: #1f2937;
          --card-bg: #0f141a;
          --pill-bg: #111827;
        }
      }
      html, body { height: 100%; }
      body {
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 0; padding: 16px; max-width: 1100px; margin-inline: auto;
      }
      fieldset {
        margin: 16px 0; border: 1px solid var(--border); border-radius: 10px;
        background: var(--card-bg);
      }
      legend { padding: 0 8px; font-weight: 600; }
      label { display: inline-block; min-width: 160px; }
      input[type="text"], input[type="url"], select { width: 100%; max-width: 520px; }
      .row { margin: 10px 0; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      .video { width: 100%; max-width: 480px; aspect-ratio: 16/9; background: #111; border-radius: 8px; }
      #log { white-space: pre-wrap; background: #0b0f14; color: #e5e7eb; border: 1px solid var(--border); padding: 8px; height: 160px; overflow: auto; border-radius: 8px; }
      .panel { height: 160px; overflow: auto; border: 1px solid var(--border); padding: 8px; border-radius: 8px; background: #0b0f14; color: #e5e7eb; white-space: pre-wrap; }
      button { margin-right: 8px; padding: 10px 14px; border-radius: 8px; border: 1px solid var(--border); background: #111827; color: #e5e7eb; cursor: pointer; }
      button:disabled { opacity: .6; cursor: not-allowed; }
      .minor { color: var(--muted); font-size: 12px; }
      .muted { color: #ef4444; font-weight: 600; }
      .badge { margin-left: 8px; padding: 2px 8px; border-radius: 10px; font-size: 12px; vertical-align: middle; }
      .badge.ok { background: #064e3b; color: #34d399; border: 1px solid #065f46; }
      .badge.pending { background: #5b3b03; color: #fde68a; border: 1px solid #78350f; }
      .badge.error { background: #7f1d1d; color: #fecaca; border: 1px solid #991b1b; }
      .remote-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 12px; }
      .remote-item { width: 100%; max-width: 320px; aspect-ratio: 16/9; background: #000; position: relative; border-radius: 8px; overflow: hidden; }
      .remote-item .label { position: absolute; left: 6px; bottom: 4px; color: #fff; background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px; font-size: 12px; }
      /* KPI row for mobile/desktop */
      .kpi-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
      .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 10px; font-weight: 700; font-size: 12px; }
      .pill.live { background: linear-gradient(90deg, var(--brand), #f43f5e); color: #fff; }
      .pill.off { background: var(--pill-bg); color: #e5e7eb; font-weight: 600; }
      .kpi { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 10px; background: var(--pill-bg); color: #e5e7eb; }
      .kpi svg { width: 16px; height: 16px; }
      .spacer { flex: 1 1 auto; }
      @media (max-width: 900px) {
        .controls { grid-template-columns: 1fr; }
        label { min-width: 120px; }
      }
      @media (max-width: 640px) {
        .row { flex-direction: column; align-items: stretch; }
        label { width: 100%; }
        input[type="text"], input[type="url"], select, button { width: 100%; }
      }
    </style>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"></script>
  </head>
  <body>
    <h1>Agora Live Streaming – Mute & Volume <span id="sdkStatus" class="badge pending">SDK: not loaded</span></h1>
    <div id="secureWarn" style="display:none;margin:10px 0;padding:8px 12px;border:1px solid #f6c343;background:#fff8e1;color:#8a6d3b;font-size:14px;border-radius:6px"></div>
    <p class="minor">Use with the token server from <code>server/</code> (default http://localhost:4000).</p>

    <fieldset>
      <legend>Join Settings</legend>
      <div class="row">
        <label for="serverOrigin">Token server</label>
        <input id="serverOrigin" type="url" value="http://localhost:4000" />
        <span class="minor">/v1/rtc/token</span>
      </div>
      <div class="row">
        <label for="channel">Channel</label>
        <input id="channel" type="text" value="demo" />
      </div>
      <div class="row">
        <label for="uid">UID</label>
        <input id="uid" type="text" placeholder="Unique per channel (auto if empty)" />
        <span class="minor">Use a unique ID per client.</span>
      </div>
      <div class="row">
        <label>Role</label>
        <label><input type="radio" name="role" value="host" checked /> Host</label>
        <label><input type="radio" name="role" value="audience" /> Audience</label>
      </div>
      <details>
        <summary>Manual token (optional)</summary>
        <div class="row">
          <label for="appId">App ID</label>
          <input id="appId" type="text" placeholder="If using manual token" />
        </div>
        <div class="row">
          <label for="token">Token</label>
          <input id="token" type="text" placeholder="Paste a temp token to skip server" />
        </div>
      </details>
      <div class="row">
        <button id="joinBtn">Join</button>
        <button id="leaveBtn" disabled>Leave</button>
      </div>
    </fieldset>

    <div class="controls">
      <fieldset>
        <legend>Local Microphone</legend>
        <div class="row">
          <label for="muteLocal">Mute</label>
          <input id="muteLocal" type="checkbox" />
          <span id="muteLocalState" class="minor">unmuted</span>
        </div>
        <div class="row">
          <label for="localVol">Capture volume</label>
          <input id="localVol" type="range" min="0" max="400" value="100" />
          <span class="minor">0–400</span>
        </div>
      </fieldset>

      <fieldset>
        <legend>Local Camera</legend>
        <div class="row">
          <label>Facing</label>
          <label><input type="radio" name="camFacing" id="camFront" value="user" checked /> Front</label>
          <label style="margin-left:8px"><input type="radio" name="camFacing" id="camBack" value="environment" /> Back</label>
          <button id="switchCamBtn" type="button" style="margin-left:8px">Switch</button>
        </div>
        <div class="row">
          <label for="camSelect">Device</label>
          <select id="camSelect" style="min-width:260px"></select>
          <label style="margin-left:8px"><input id="mirrorPreview" type="checkbox" checked /> Mirror preview</label>
        </div>
      </fieldset>

      <fieldset>
        <legend>Remote Playback</legend>
        <div class="row">
          <label for="remoteVol">Playback volume</label>
          <input id="remoteVol" type="range" min="0" max="100" value="100" disabled />
          <span class="minor">0–100</span>
        </div>
        <div class="row minor">
          Remote users: <span id="remoteCount">0</span>
        </div>
      </fieldset>
    </div>

    <fieldset>
      <legend>Preview (Local)</legend>
      <video id="localVideo" class="video" autoplay playsinline muted style="transform: scaleX(-1);"></video>
    </fieldset>

    <fieldset>
      <legend>Live Backend (FastAPI) – Presence & Duration</legend>
      <div class="kpi-row" style="margin:8px 12px 0 12px">
        <span id="liveBadge" class="pill off" title="WebSocket status">LIVE</span>
        <span class="kpi" title="Current non-vendor viewers">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7Z"/><circle cx="12" cy="12" r="3"/></svg>
          <strong id="viewerCountLabel">0</strong>
        </span>
        <span class="kpi" title="Unique viewers this session">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7Z"/><circle cx="12" cy="12" r="0.01"/></svg>
          <strong id="viewsTotalLabel">0</strong>
        </span>
        <span class="kpi" title="Elapsed live duration"><strong id="liveDurationLabel">00:00:00</strong></span>
        <span class="spacer"></span>
      </div>
      <div class="row" style="padding:8px 12px 0 12px">
        <label for="backendOrigin">Backend origin</label>
        <input id="backendOrigin" type="url" value="http://localhost:8000" />
      </div>
      <div class="row" style="padding:0 12px">
        <label for="liveSessionId">Session ID</label>
        <input id="liveSessionId" type="text" placeholder="sess_xxx from /live/sessions or /active" />
      </div>
      <div class="row" style="padding:0 12px 8px 12px">
        <label for="jwtToken">JWT</label>
        <input id="jwtToken" type="text" placeholder="Paste Bearer JWT (from /auth/login)" />
      </div>
      <div class="row" style="padding:0 12px 12px 12px">
        <button id="connectLiveBtn" type="button">Connect Live WS</button>
        <button id="disconnectLiveBtn" type="button" disabled>Disconnect</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Remote Video</legend>
      <div id="remoteVideos" class="remote-grid"></div>
    </fieldset>

    <fieldset>
      <legend>Log</legend>
      <div id="log"></div>
    </fieldset>

    <fieldset>
      <legend>Comments (Signaling)</legend>
      <div class="row">
        <div id="chatLog" class="panel"></div>
      </div>
      <div class="row">
        <input id="chatInput" type="text" placeholder="Type a comment…" />
        <label style="margin-left:8px"><input id="dmToHost" type="checkbox" /> Send to Host privately</label>
        <span class="minor" style="margin-left:8px">Host UID: <span id="hostUidLabel">unknown</span></span>
        <button id="sendBtn" style="margin-left:8px" type="button">Send</button>
      </div>
    </fieldset>

    <script>
      const $ = (id) => document.getElementById(id);
      const logEl = $("log");
      function log(...args) {
        const line = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
        const time = new Date().toLocaleTimeString();
        logEl.textContent += `[${time}] ${line}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      // Surface runtime errors in the on-page log for easier debugging
      window.addEventListener('error', (e) => {
        try { log('Runtime error:', e.message); } catch (_) {}
      });
      window.addEventListener('unhandledrejection', (e) => {
        try { const msg = (e.reason && (e.reason.message || String(e.reason))) || 'unhandled rejection'; log(msg); } catch (_) {}
      });
      log('Demo script loaded');
      // Secure context check (getUserMedia requires HTTPS except on localhost)
      (function enforceSecureContext(){
        try {
          const warn = document.getElementById('secureWarn');
          const joinBtn = document.getElementById('joinBtn');
          const isLocalhost = /^(localhost|127\.0\.0\.1|\[::1\])$/.test(location.hostname);
          if (!window.isSecureContext && !isLocalhost) {
            const httpsUrl = `https://${location.host}${location.pathname}`;
            warn.innerHTML = `This page is not in a secure context. Browsers block mic/camera on HTTP.<br/>Open the secure link: <a href="${httpsUrl}">${httpsUrl}</a>`;
            warn.style.display = 'block';
          }
        } catch(_) {}
      })();
      // SDK status indicator helpers
      const sdkStatusEl = document.getElementById('sdkStatus');
      function setSdkStatus(text, cls) {
        if (!sdkStatusEl) return;
        sdkStatusEl.textContent = text;
        sdkStatusEl.className = `badge ${cls}`;
      }
      if (window.AgoraRTC) {
        const ver = window.AgoraRTC.VERSION || window.AgoraRTC.version || '';
        setSdkStatus(`SDK: loaded ${ver}`.trim(), 'ok');
      } else {
        setSdkStatus('SDK: not loaded', 'pending');
      }

      // Simple dynamic loader to ensure Agora SDK is present
      const SDK_CANDIDATES = [
        'https://download.agora.io/sdk/release/AgoraRTC_N.js',
        'https://download.agora.io/sdk/release/AgoraRTC_N-4.20.2.js',
        'https://cdn.jsdelivr.net/npm/agora-rtc-sdk-ng@4.20.2/AgoraRTC_N.js',
        'https://cdn.jsdelivr.net/npm/agora-rtc-sdk-ng@4.20.2/AgoraRTC_N-4.20.2.js'
      ];
      function isSameOrigin(u) {
        try { return new URL(u, location.href).origin === location.origin; } catch (_) { return false; }
      }
      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src; s.async = true;
          // Avoid setting crossOrigin for same-origin scripts (iOS WebKit quirk)
          if (!isSameOrigin(src)) s.crossOrigin = 'anonymous';
          s.onload = () => resolve();
          s.onerror = () => reject(new Error('Failed to load ' + src));
          document.head.appendChild(s);
        });
      }
      async function ensureAgoraSdk() {
        if (window.AgoraRTC) return window.AgoraRTC;
        for (const url of SDK_CANDIDATES) {
          try {
            setSdkStatus('SDK: loading…', 'pending');
            log('Loading SDK:', url);
            await loadScript(url);
            if (window.AgoraRTC) {
              const ver = window.AgoraRTC.VERSION || window.AgoraRTC.version || '';
              setSdkStatus(`SDK: loaded ${ver}`.trim(), 'ok');
              return window.AgoraRTC;
            }
          } catch (e) {
            log(e.message || e);
          }
        }
        setSdkStatus('SDK: failed to load', 'error');
        throw new Error('Unable to load Agora Web SDK');
      }

      // RTM/Signaling SDK loader
      const RTM_CANDIDATES = [
        // Same-origin proxy served by the token server to avoid iOS security errors on self-signed certs
        `${location.origin.replace(/\/$/, '')}/demo/rtm/agora-rtm.js`,
        'https://cdn.jsdelivr.net/npm/agora-rtm-sdk@2.2.3/agora-rtm.js',
        'https://unpkg.com/agora-rtm-sdk@2.2.3/agora-rtm.js'
      ];
      async function ensureRtmSdk() {
        if (window.AgoraRTM) return window.AgoraRTM;
        for (const url of RTM_CANDIDATES) {
          try { log('Loading RTM SDK:', url); await loadScript(url); if (window.AgoraRTM) return window.AgoraRTM; } catch (e) { log(e.message || e); }
        }
        throw new Error('Unable to load RTM SDK');
      }

      // When served from /demo, use the same origin for token server (works for IP/localhost, http/https)
      (function initServerOriginDefault() {
        try {
          const input = $("serverOrigin");
          if (!input) return;
          // only override when running under our demo route
          if (location.pathname.startsWith('/demo')) {
            input.value = location.origin;
          }
        } catch (_) { /* noop */ }
      })();

      // Ensure UID has a unique default if empty
      (function ensureDefaultUid() {
        const uidEl = $("uid");
        if (uidEl && !uidEl.value) {
          const rand = Math.random().toString(36).slice(2, 8);
          uidEl.value = `user_${rand}`;
        }
      })();

      let client;
      let localAudioTrack;
      let localVideoTrack;
      let joined = false;
      const remoteUsers = new Map(); // uid -> { audioTrack, videoTrack }
      let currentRemoteAudioTrack = null;
      let rtm; // RTM client
      let rtmChannelName = '';
      let hostUid = '';

      async function fetchRtcToken(serverOrigin, channel, role, uid) {
        const params = new URLSearchParams({ channelName: channel, role, uid });
        const url = `${serverOrigin.replace(/\/$/, '')}/v1/rtc/token?${params}`;
        log('Fetching RTC token:', url);
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Token fetch failed: ${res.status}`);
        return res.json();
      }

      function getRole() {
        const el = document.querySelector('input[name="role"]:checked');
        return el ? el.value : 'audience';
      }

      function setUiJoined(state) {
        joined = state;
        $("joinBtn").disabled = state;
        $("leaveBtn").disabled = !state;
      }

      function updateRemoteState() {
        $("remoteCount").textContent = String(remoteUsers.size);
        const first = remoteUsers.values().next().value;
        currentRemoteAudioTrack = first ? first.audioTrack : null;
        $("remoteVol").disabled = !currentRemoteAudioTrack;
      }

      async function refreshCameraList() {
        try {
          const cams = await AgoraRTC.getCameras();
          const sel = document.getElementById('camSelect');
          if (!sel) return;
          const old = sel.value;
          sel.innerHTML = '';
          for (const c of cams) {
            const opt = document.createElement('option');
            opt.value = c.deviceId;
            opt.textContent = c.label || `Camera ${c.deviceId.slice(0,6)}`;
            sel.appendChild(opt);
          }
          // restore selection if possible
          if (old) sel.value = old;
        } catch (_) {}
      }

      function getPreferredFacing() {
        const el = document.querySelector('input[name="camFacing"]:checked');
        return el ? el.value : 'user';
      }

      async function switchCameraByFacing(facing) {
        try {
          if (!localVideoTrack) return;
          const cams = await AgoraRTC.getCameras();
          // Try label match first
          const lc = (s) => (s||'').toLowerCase();
          let target = cams.find(c => /back|rear|environment/.test(lc(c.label))) ;
          if (facing === 'user') {
            target = cams.find(c => /front|user|face/.test(lc(c.label)));
          }
          // Fallback: pick first/last
          if (!target && cams.length) target = facing === 'user' ? cams[0] : cams[cams.length-1];
          if (target) {
            await localVideoTrack.setDevice(target.deviceId);
            localVideoTrack.play('localVideo');
            await refreshCameraList();
            document.getElementById('camSelect').value = target.deviceId;
            log('Switched camera to', target.label || target.deviceId);
          }
        } catch (e) { log('Switch camera error:', e.message || e); }
      }

      function updateHostUidLabel() {
        document.getElementById('hostUidLabel').textContent = hostUid || 'unknown';
      }

      async function join() {
        try {
          if (joined) return;
          if (!window.isSecureContext && !/^(localhost|127\.0\.0\.1|\[::1\])$/.test(location.hostname) && getRole()==='host') {
            throw new Error('This page is HTTP. Use HTTPS to publish mic/cam.');
          }
          // Ensure SDK is available
          await ensureAgoraSdk();
          const channel = $("channel").value.trim();
          const uid = $("uid").value.trim() || '0';
          const role = getRole();
          let appId, token, finalUid = uid;

          const manualToken = $("token").value.trim();
          if (manualToken) {
            appId = $("appId").value.trim();
            token = manualToken;
            if (!appId || !token) throw new Error('Manual token requires App ID and Token');
          } else {
            const serverOrigin = $("serverOrigin").value.trim() || 'http://localhost:4000';
            const t = await fetchRtcToken(serverOrigin, channel, role, uid);
            appId = t.appId; token = t.token; finalUid = String(t.uid ?? uid);
          }

          client = AgoraRTC.createClient({ mode: 'live', codec: 'vp8' });
          client.on('user-published', async (user, mediaType) => {
            log('user-published', user.uid, mediaType);
            await client.subscribe(user, mediaType);
            log('subscribed', user.uid, mediaType);
            if (!remoteUsers.has(user.uid)) remoteUsers.set(user.uid, {});
            const entry = remoteUsers.get(user.uid);
            if (mediaType === 'audio') {
              entry.audioTrack = user.audioTrack;
              try {
                await user.audioTrack.play(); // start playback
                log('remote audio playing', user.uid);
              } catch (err) {
                log('remote audio play error:', err.message || err);
              }
            } else if (mediaType === 'video') {
              entry.videoTrack = user.videoTrack;
              // Create container and play remote video
              const containerId = `remote-${user.uid}`;
              let el = document.getElementById(containerId);
              if (!el) {
                el = document.createElement('div');
                el.id = containerId;
                el.className = 'remote-item';
                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = `uid: ${user.uid}`;
                el.appendChild(label);
                const host = document.getElementById('remoteVideos');
                if (host) host.appendChild(el);
              }
              try {
                user.videoTrack.play(el);
                log('remote video playing', user.uid);
              } catch (err) {
                log('remote video play error:', err.message || err);
              }
              // Heuristic: the first remote with video is likely the Host
              if (!hostUid) { hostUid = String(user.uid); updateHostUidLabel(); }
            }
            updateRemoteState();
          });
          function cleanupRemote(user, mediaType) {
            log('user-unpublished', user.uid, mediaType);
            const entry = remoteUsers.get(user.uid);
            if (entry) {
              if (mediaType === 'audio' && entry.audioTrack) { entry.audioTrack.stop(); entry.audioTrack = null; }
              if (mediaType === 'video' && entry.videoTrack) {
                entry.videoTrack.stop();
                entry.videoTrack = null;
                const el = document.getElementById(`remote-${user.uid}`);
                if (el && el.parentNode) el.parentNode.removeChild(el);
              }
              if (!entry.audioTrack && !entry.videoTrack) remoteUsers.delete(user.uid);
            }
            if (String(user.uid) === hostUid && mediaType !== 'audio') { hostUid = ''; updateHostUidLabel(); }
            updateRemoteState();
          }
          client.on('user-unpublished', cleanupRemote);
          client.on('user-left', (user) => cleanupRemote(user, 'all'));

          client.setClientRole(role);
          await client.join(appId, channel, token || null, finalUid === '0' ? null : finalUid);
          log('Joined channel', channel, 'as', role, 'uid', finalUid);

          if (role === 'host') {
            const facing = getPreferredFacing();
            [localAudioTrack, localVideoTrack] = await Promise.all([
              AgoraRTC.createMicrophoneAudioTrack(),
              AgoraRTC.createCameraVideoTrack({ facingMode: facing })
            ]);
            localVideoTrack.play('localVideo');
            await client.publish([localAudioTrack, localVideoTrack]);
            log('Published local tracks');
            hostUid = String(finalUid);
            updateHostUidLabel();
            await refreshCameraList();
          }

          // Connect RTM and subscribe to comments channel (same as RTC channel)
          try {
            await ensureRtmConnected(channel, String(finalUid));
          } catch (err) {
            log('RTM error:', err.message || err);
          }

          setUiJoined(true);
        } catch (e) {
          log('Join error:', e.message || e);
          alert(e.message || e);
        }
      }

      async function leave() {
        try {
          if (!client) return;
          if (localVideoTrack) { localVideoTrack.stop(); localVideoTrack.close(); localVideoTrack = null; }
          if (localAudioTrack) { localAudioTrack.stop(); localAudioTrack.close(); localAudioTrack = null; }
          await client.unpublish();
          await client.leave();
          client.removeAllListeners();
          client = null;
          remoteUsers.clear();
          currentRemoteAudioTrack = null;
          if (rtm) {
            try { if (rtmChannelName) await rtm.unsubscribe(rtmChannelName); } catch (_) {}
            try { await rtm.logout(); } catch (_) {}
          }
          rtm = null; rtmChannelName='';
          updateRemoteState();
          setUiJoined(false);
          log('Left channel');
        } catch (e) {
          log('Leave error:', e.message || e);
        }
      }

      $("joinBtn").addEventListener('click', () => join());
      $("leaveBtn").addEventListener('click', () => leave());

      $("muteLocal").addEventListener('change', async (e) => {
        const muted = e.target.checked;
        try {
          if (localAudioTrack) {
            await localAudioTrack.setEnabled(!muted);
            $("muteLocalState").textContent = muted ? 'muted' : 'unmuted';
            $("muteLocalState").className = muted ? 'muted' : 'minor';
          }
        } catch (err) { log('Mute error:', err.message || err); }
      });

      $("localVol").addEventListener('input', (e) => {
        const v = Number(e.target.value);
        if (localAudioTrack) {
          try { localAudioTrack.setVolume(v); } catch (_) {}
        }
      });

      $("remoteVol").addEventListener('input', (e) => {
        const v = Number(e.target.value);
        if (currentRemoteAudioTrack) {
          try { currentRemoteAudioTrack.setVolume(v); } catch (_) {}
        }
      });

      // Camera controls
      document.getElementById('switchCamBtn').addEventListener('click', async () => {
        const facing = getPreferredFacing();
        await switchCameraByFacing(facing);
      });
      document.getElementById('camSelect').addEventListener('change', async (e) => {
        try {
          if (localVideoTrack) {
            await localVideoTrack.setDevice(e.target.value);
            localVideoTrack.play('localVideo');
          }
        } catch (err) { log('Switch by device error:', err.message || err); }
      });
      document.getElementById('camFront').addEventListener('change', async (e) => { if (e.target.checked) await switchCameraByFacing('user'); });
      document.getElementById('camBack').addEventListener('change', async (e) => { if (e.target.checked) await switchCameraByFacing('environment'); });
      document.getElementById('mirrorPreview').addEventListener('change', (e) => {
        const v = document.getElementById('localVideo');
        if (e.target.checked) { v.style.transform = 'scaleX(-1)'; }
        else { v.style.transform = ''; }
      });

      // Initialize UI state
      updateRemoteState();

      // Chat helpers
      function appendChat(text) {
        const log = document.getElementById('chatLog');
        if (!log) return;
        const time = new Date().toLocaleTimeString();
        log.textContent += `[${time}] ${text}\n`;
        log.scrollTop = log.scrollHeight;
      }
      let rtmSelfUid = null;
      async function ensureRtmConnected(channel, uid) {
        await ensureRtmSdk();
        // Sanitize channel for RTM (no dots or spaces; <=64 chars)
        function rtmSafeChannel(name) {
          const cleaned = String(name || '')
            .replace(/[^A-Za-z0-9_-]/g, '-')
            .replace(/-+/g, '-');
          return cleaned.slice(0, 64) || 'rtm';
        }
        const rtmChannel = rtmSafeChannel(channel);
        if (rtm && rtmChannelName === rtmChannel) { return rtm; }
        const origin = ($("serverOrigin").value.trim() || location.origin).replace(/\/$/, '');
        const r = await fetch(`${origin}/v1/rtm/token?uid=${encodeURIComponent(uid)}`);
        if (!r.ok) throw new Error('RTM token fetch failed');
        const { appId: rtmAppId, token: rtmToken } = await r.json();
        rtm = new AgoraRTM.RTM(rtmAppId, String(uid));
        rtmSelfUid = String(uid);
        rtm.addEventListener('status', (s) => log('RTM status', s.state, s.reason||''));
        rtm.addEventListener('message', (m) => {
          if (m.messageType !== 'STRING') return;
          if (m.channelType === 'MESSAGE' && m.channelName === rtmChannelName) {
            // Hide own group messages from self
            if (String(m.publisher) === String(rtmSelfUid)) return;
            appendChat(`${m.publisher}: ${m.message}`);
          } else if (m.channelType === 'USER') {
            appendChat(`DM ${m.publisher}: ${m.message}`);
          }
        });
        await rtm.login({ token: rtmToken });
        rtmChannelName = rtmChannel;
        await rtm.subscribe(rtmChannelName);
        log('RTM subscribed', rtmChannelName);
        return rtm;
      }

      let sending = false;
      async function sendChat() {
        if (sending) return;
        const inp = document.getElementById('chatInput');
        const msg = inp.value.trim();
        if (!msg) return;
        try {
          sending = true;
          const channel = $("channel").value.trim();
          const uidNow = $("uid").value.trim() || '0';
          if (!rtm || !rtmChannelName) {
            await ensureRtmConnected(channel, uidNow);
          }
          const dm = document.getElementById('dmToHost').checked;
          const myRole = getRole();
          if (dm && hostUid && myRole !== 'host') {
            await rtm.publish(hostUid, msg, { channelType: 'USER', storeInHistory: false });
            appendChat(`me → host(${hostUid}): ${msg}`);
          } else {
            await rtm.publish(rtmChannelName, msg, { channelType: 'MESSAGE', storeInHistory: false });
            // Show own message immediately in UI
            appendChat(`me (all): ${msg}`);
          }
          inp.value = '';
        } catch (e) { log('Send error:', e.message || e); }
        finally { sending = false; }
      }
      document.getElementById('sendBtn').addEventListener('click', sendChat);
      document.getElementById('chatInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); sendChat(); }
      });

      // ------------------------------
      // FastAPI live WS (presence + duration)
      // ------------------------------
      let liveWs = null;
      let liveTicker = null;
      let liveDurationSeconds = 0;
      let liveStartedAt = null; // ISO string or null
      let liveEnded = false;
      function fmtHMS(secs) {
        secs = Math.max(0, Math.floor(Number(secs)||0));
        const h = String(Math.floor(secs / 3600)).padStart(2,'0');
        const m = String(Math.floor((secs % 3600) / 60)).padStart(2,'0');
        const s = String(secs % 60).padStart(2,'0');
        return `${h}:${m}:${s}`;
      }
      function setLiveUi(connected) {
        const c = document.getElementById('connectLiveBtn');
        const d = document.getElementById('disconnectLiveBtn');
        if (c) c.disabled = connected;
        if (d) d.disabled = !connected;
        const live = document.getElementById('liveBadge');
        if (live) {
          live.className = 'pill ' + (connected ? 'live' : 'off');
          live.textContent = connected ? 'LIVE' : 'OFFLINE';
        }
      }
      function updateDurationLabel() {
        const el = document.getElementById('liveDurationLabel');
        if (el) el.textContent = fmtHMS(liveDurationSeconds);
      }
      function startTicker() {
        stopTicker();
        updateDurationLabel();
        liveTicker = setInterval(() => {
          if (liveEnded) { stopTicker(); return; }
          liveDurationSeconds += 1;
          updateDurationLabel();
        }, 1000);
      }
      function stopTicker() { if (liveTicker) { clearInterval(liveTicker); liveTicker = null; } }
      function updateViewerCount(n) {
        const el = document.getElementById('viewerCountLabel');
        if (el) el.textContent = String(n);
      }
      function updateViewsTotal(n) {
        const el = document.getElementById('viewsTotalLabel');
        if (el) el.textContent = String(n);
      }
      function connectLiveWs() {
        try {
          const origin = (document.getElementById('backendOrigin').value || '').replace(/\/$/, '');
          const sid = (document.getElementById('liveSessionId').value || '').trim();
          const jwt = (document.getElementById('jwtToken').value || '').trim();
          if (!origin || !sid || !jwt) {
            alert('Please fill Backend origin, Session ID, and JWT');
            return;
          }
          const url = `${origin.replace('http','ws')}/ws/live/${encodeURIComponent(sid)}?token=${encodeURIComponent(jwt)}`;
          log('Connecting live WS:', url);
          liveWs = new WebSocket(url);
          liveWs.onopen = () => { setLiveUi(true); log('Live WS connected'); };
          liveWs.onclose = (e) => { setLiveUi(false); log('Live WS closed', e.code, e.reason||''); stopTicker(); };
          liveWs.onerror = (e) => { log('Live WS error'); };
          liveWs.onmessage = (ev) => {
            try {
              const data = JSON.parse(ev.data);
              if (data.type === 'viewer_count') {
                updateViewerCount(data.count || 0);
                return;
              }
              if (data.type === 'views_total') {
                updateViewsTotal(data.total || 0);
                return;
              }
              if (data.type === 'session_info') {
                liveStartedAt = data.started_at || null;
                liveEnded = !!data.ended_at;
                // Prefer server-provided seconds as baseline
                liveDurationSeconds = Number(data.live_duration_seconds||0);
                startTicker();
                if (typeof data.viewer_count === 'number') updateViewerCount(data.viewer_count);
                if (typeof data.views_total === 'number') updateViewsTotal(data.views_total);
                return;
              }
              if (data.type === 'session_ended') {
                liveEnded = true;
                if (typeof data.live_duration_seconds === 'number') {
                  liveDurationSeconds = data.live_duration_seconds;
                  updateDurationLabel();
                }
                stopTicker();
                return;
              }
            } catch(_) {}
          };
        } catch (e) {
          log('Live WS connect error:', e.message || e);
        }
      }
      function disconnectLiveWs() {
        try { if (liveWs && liveWs.readyState === 1) liveWs.close(1000, 'client close'); } catch(_) {}
        liveWs = null; stopTicker(); setLiveUi(false);
      }
      document.getElementById('connectLiveBtn').addEventListener('click', connectLiveWs);
      document.getElementById('disconnectLiveBtn').addEventListener('click', disconnectLiveWs);
    </script>
  </body>
  </html>
